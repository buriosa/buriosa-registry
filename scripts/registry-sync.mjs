import fs from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

function rootDir() {
  return path.resolve(__dirname, "..");
}

async function exists(p) {
  try {
    await fs.access(p);
    return true;
  } catch {
    return false;
  }
}

async function ensureDir(p) {
  await fs.mkdir(p, { recursive: true });
}

async function copyDir(src, dest) {
  await ensureDir(dest);
  // Node 18+ : fs.cp 사용 가능
  await fs.cp(src, dest, { recursive: true, force: true });
}

function toPascalCase(kebab) {
  const parts = kebab.split("-").filter(Boolean);
  let s = parts.map(p => p.charAt(0).toUpperCase() + p.slice(1)).join("");
  // 숫자로 시작하면 식별자 에러 나니까 접두어 붙임
  if (/^[0-9]/.test(s)) s = `C${s}`;
  return s || "Component";
}

async function generateRegistryComponentsTs(componentNames, outFile) {
  const lines = [];
  lines.push(`// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.`);
  lines.push(`// Generated by scripts/registry-sync.mjs`);
  lines.push(``);

  for (const name of componentNames) {
    const id = toPascalCase(name);
    lines.push(`import ${id} from "@registry/${name}";`);
  }

  lines.push(``);
  lines.push(`export const REGISTRY_COMPONENTS = {`);
  for (const name of componentNames) {
    const id = toPascalCase(name);
    lines.push(`  "${name}": ${id},`);
  }
  lines.push(`} as const;`);
  lines.push(``);
  lines.push(`export type RegistryComponentName = keyof typeof REGISTRY_COMPONENTS;`);
  lines.push(``);

  await fs.writeFile(outFile, lines.join("\n"), "utf-8");
}

async function main() {
  const root = rootDir();

  const indexSrc = path.join(root, "public", "registry", "index.json");
  const previewSrcDir = path.join(root, "public", "registry", "preview");
  const componentsSrcDir = path.join(root, "src", "components", "registry");

  if (!(await exists(indexSrc))) {
    throw new Error(
      `index.json이 없음: ${indexSrc}\n` +
      `먼저 이걸 실행해: python scripts/registry-build.py`
    );
  }

  // 1) index.json 배송
  const indexDest = path.join(root, "apps", "web", "public", "registry", "index.json");
  await ensureDir(path.dirname(indexDest));
  await fs.copyFile(indexSrc, indexDest);

  // 2) preview 이미지 배송 (있으면)
  const previewDestDir = path.join(root, "apps", "web", "public", "registry", "preview");
  if (await exists(previewSrcDir)) {
    await copyDir(previewSrcDir, previewDestDir);
  } else {
    await ensureDir(previewDestDir);
  }

  // 3) 컴포넌트 배송 (apps/web에서 직접 참조)
  const componentsDestDir = path.join(root, "apps", "web", "components", "registry");
  await copyDir(componentsSrcDir, componentsDestDir);

  // 4) registry-components.ts 자동 생성(수동 매핑 제거)
  const entries = await fs.readdir(componentsSrcDir, { withFileTypes: true });
  const componentNames = entries
    .filter(d => d.isDirectory())
    .map(d => d.name)
    .sort((a, b) => a.localeCompare(b));

  const registryMapFile = path.join(
    root,
    "apps",
    "web",
    "app",
    "registry",
    "registry-components.ts"
  );

  await generateRegistryComponentsTs(componentNames, registryMapFile);

  console.log(`[SYNC OK] index.json + preview + registry-components.ts`);
  console.log(`- ${path.relative(root, indexDest)}`);
  console.log(`- ${path.relative(root, previewDestDir)}`);
  console.log(`- ${path.relative(root, componentsDestDir)}`);
  console.log(`- ${path.relative(root, registryMapFile)}`);
}

main().catch((e) => {
  console.error(e?.message ?? e);
  process.exit(1);
});
